<!DOCTYPE html>
<html>
<head>
    <title>Procedural FPS: Phase 2</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; user-select: none; }
        #hud { position: absolute; bottom: 20px; left: 20px; color: #0f0; font-size: 24px; text-shadow: 0 0 5px #0f0; pointer-events: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; background: #0f0; transform: translate(-50%, -50%); border-radius: 50%; pointer-events: none; mix-blend-mode: difference; }
        #instr { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #0f0; }
    </style>
</head>
<body>
    <div id="hud">HEALTH: 100 | SCORE: 0</div>
    <div id="crosshair"></div>
    <div id="instr">CLICK TO START<br>WASD to Move | Click to Shoot</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- SYSTEM CONSTANTS ---
        let camera, scene, renderer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3(), direction = new THREE.Vector3();
        let prevTime = performance.now();
        let enemies = [];
        let bullets = [];
        let player = { health: 100, score: 0 };
        let isLocked = false;

        // --- 1. PROCEDURAL AUDIO ENGINE (The "No MP3" Solution) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;
            
            if (type === 'shoot') {
                // Laser Zap
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'hit') {
                // Low thud
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.2);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            }
        }

        // --- 2. PROCEDURAL TEXTURES ---
        function createTexture(color1, color2, noiseScale) {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color1;
            ctx.fillRect(0,0,size,size);
            
            for(let i=0; i<noiseScale; i++) {
                ctx.fillStyle = color2;
                ctx.globalAlpha = 0.1;
                ctx.fillRect(Math.random()*size, Math.random()*size, Math.random()*50, Math.random()*50);
            }
            // Grunge lines
            ctx.globalAlpha = 0.3;
            ctx.strokeStyle = color2;
            for(let i=0; i<20; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random()*size, Math.random()*size);
                ctx.lineTo(Math.random()*size, Math.random()*size);
                ctx.stroke();
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        // --- 3. INIT GAME WORLD ---
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.05);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: false }); // False for retro feel
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Level Generation
            const wallMat = new THREE.MeshStandardMaterial({ map: createTexture('#222', '#555', 4000), roughness: 0.9 });
            const floorMat = new THREE.MeshStandardMaterial({ map: createTexture('#111', '#333', 2000), roughness: 0.5 });
            
            const geo = new THREE.BoxGeometry(1,1,1);
            
            // Create a randomized arena
            for(let x=-20; x<=20; x+=2) {
                for(let z=-20; z<=20; z+=2) {
                    // Floor
                    let floor = new THREE.Mesh(geo, floorMat);
                    floor.position.set(x, -1, z);
                    floor.scale.set(2, 0.1, 2);
                    scene.add(floor);

                    // Random Pillars/Walls
                    if(Math.random() > 0.8 && (x!==0 || z!==0)) {
                        let h = 2 + Math.random() * 3;
                        let wall = new THREE.Mesh(geo, wallMat);
                        wall.position.set(x, h/2 - 1, z);
                        wall.scale.set(2, h, 2);
                        scene.add(wall);
                    }
                }
            }

            // Lighting
            const ambient = new THREE.AmbientLight(0x404040);
            scene.add(ambient);
            const point = new THREE.PointLight(0x00ff00, 1, 15);
            point.position.set(0, 5, 0);
            scene.add(point);

            // Controls Setup
            document.body.addEventListener('click', () => {
                document.body.requestPointerLock();
                // Shooting
                if(isLocked) shoot();
            });

            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === document.body;
                document.getElementById('instr').style.display = isLocked ? 'none' : 'block';
            });

            document.addEventListener('mousemove', (e) => {
                if(isLocked) {
                    camera.rotation.y -= e.movementX * 0.002;
                    camera.rotation.x -= e.movementY * 0.002;
                    camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                }
            });

            document.addEventListener('keydown', (e) => onKey(e.code, true));
            document.addEventListener('keyup', (e) => onKey(e.code, false));
        }

        function onKey(code, state) {
            switch(code) {
                case 'KeyW': moveForward = state; break;
                case 'KeyS': moveBackward = state; break;
                case 'KeyA': moveLeft = state; break;
                case 'KeyD': moveRight = state; break;
            }
        }

        // --- 4. GAME LOGIC ---
        
        function spawnEnemy() {
            if(enemies.length > 5) return; // Limit count
            const geometry = new THREE.IcosahedronGeometry(0.5, 0);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xff0000, 
                emissive: 0x550000,
                wireframe: true 
            });
            const enemy = new THREE.Mesh(geometry, material);
            
            // Random spawn pos
            const angle = Math.random() * Math.PI * 2;
            const dist = 10 + Math.random() * 10;
            enemy.position.set(Math.sin(angle)*dist, 0, Math.cos(angle)*dist);
            
            scene.add(enemy);
            enemies.push({ mesh: enemy, hp: 3 });
        }

        function shoot() {
            playSound('shoot');
            
            // Visual Muzzle Flash
            const flash = new THREE.PointLight(0xffff00, 2, 5);
            flash.position.copy(camera.position);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 50);

            // Raycasting logic
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            
            // Check hits
            const hitObjects = enemies.map(e => e.mesh);
            const intersects = raycaster.intersectObjects(hitObjects);

            if(intersects.length > 0) {
                const hitMesh = intersects[0].object;
                const enemyData = enemies.find(e => e.mesh === hitMesh);
                if(enemyData) {
                    enemyData.hp--;
                    playSound('hit');
                    hitMesh.scale.multiplyScalar(0.8); // Shrink effect
                    if(enemyData.hp <= 0) {
                        scene.remove(hitMesh);
                        enemies = enemies.filter(e => e !== enemyData);
                        player.score += 100;
                        document.getElementById('hud').innerText = `HEALTH: ${player.health} | SCORE: ${player.score}`;
                    }
                }
            }
        }

        function update() {
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            // Spawn Enemies
            if(Math.random() < 0.01) spawnEnemy();

            // Player Movement
            if (isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 40.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 40.0 * delta;

                camera.translateX(-velocity.x * delta);
                camera.translateZ(-velocity.z * delta);
                
                // Keep player on floor
                camera.position.y = 0; 
            }

            // Enemy Logic
            enemies.forEach(e => {
                e.mesh.rotation.x += delta;
                e.mesh.rotation.y += delta;
                // Move toward player
                const vec = new THREE.Vector3().subVectors(camera.position, e.mesh.position).normalize();
                e.mesh.position.add(vec.multiplyScalar(delta * 2));
                
                // Damage Player
                if(e.mesh.position.distanceTo(camera.position) < 1) {
                    player.health -= 1;
                    document.getElementById('hud').innerText = `HEALTH: ${player.health} | SCORE: ${player.score}`;
                    if(player.health <= 0) {
                         alert("GAME OVER. Score: " + player.score);
                         player.health = 100; player.score = 0;
                         enemies.forEach(en => scene.remove(en.mesh));
                         enemies = [];
                         camera.position.set(0,0,0);
                    }
                }
            });

            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }

        init();
        update();
    </script>
</body>
</html>