<!DOCTYPE html>
<html>
<head>
    <title>Procedural FPS: Phase 3.5 (Fixed)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; user-select: none; }
        #hud { position: absolute; bottom: 20px; left: 20px; color: #0f0; font-size: 24px; text-shadow: 0 0 5px #0f0; pointer-events: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid #0f0; transform: translate(-50%, -50%); border-radius: 50%; pointer-events: none; mix-blend-mode: difference; }
        #instr { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #0f0; z-index: 10; cursor: pointer; }
        .dot { position: absolute; width: 4px; height: 4px; background: #0f0; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    </style>
</head>
<body>
    <div id="hud">HEALTH: 100 | SCORE: 0</div>
    <div id="crosshair"><div class="dot"></div></div>
    <div id="instr">
        <h3>PHASE 3.5: FIXED</h3>
        CLICK TO START<br>
        WASD to Move | Click to Shoot (Shotgun)
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- SYSTEM CONSTANTS ---
        let camera, scene, renderer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3(), direction = new THREE.Vector3();
        let prevTime = performance.now();
        let enemies = [];
        let player = { health: 100, score: 0 };
        let isLocked = false;
        
        // MAZE CONFIG
        const TILE_SIZE = 5; // Made tiles slightly larger for easier movement
        const MAZE_SIZE = 15; 
        let mapData = []; 

        // --- 1. AUDIO (Volume Lowered slightly) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            
            if (type === 'shoot') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.1);
                gain.gain.setValueAtTime(0.2, now); // Lower volume
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'hit') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.1);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
        }

        // --- 2. TEXTURES ---
        function createTexture(color1, color2, noiseScale) {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color1;
            ctx.fillRect(0,0,size,size);
            
            // Lighter noise for better visibility
            for(let i=0; i<noiseScale; i++) {
                ctx.fillStyle = color2;
                ctx.globalAlpha = 0.2; 
                const s = Math.random() * 30;
                ctx.fillRect(Math.random()*size, Math.random()*size, s, s);
            }
            // Stronger borders
            ctx.globalAlpha = 1.0;
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 8;
            ctx.strokeRect(0,0,size,size);

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        // --- 3. MAZE GENERATION ---
        function generateMaze(width, height) {
            let maze = Array(height).fill().map(() => Array(width).fill(1));
            
            // Recursive Backtracker
            function carve(x, y) {
                maze[y][x] = 0; 
                const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);
                for (let [dx, dy] of directions) {
                    const nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                        maze[y + dy/2][x + dx/2] = 0; 
                        carve(nx, ny);
                    }
                }
            }
            carve(1, 1);
            // Ensure center is open for gameplay flow
            maze[7][7] = 0; maze[7][8] = 0; maze[8][7] = 0;
            return maze;
        }

        // --- 4. INIT ---
        function init() {
            scene = new THREE.Scene();
            // Lighter Fog
            scene.fog = new THREE.FogExp2(0x111111, 0.08); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            mapData = generateMaze(MAZE_SIZE, MAZE_SIZE);

            // Bright Materials
            const wallTex = createTexture('#666', '#999', 1000); // Lighter Grey
            const wallMat = new THREE.MeshStandardMaterial({ map: wallTex, roughness: 0.5 });
            const floorMat = new THREE.MeshStandardMaterial({ map: createTexture('#333', '#555', 500), roughness: 0.8 });
            
            const geo = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE);

            // Build Level
            for(let y=0; y<MAZE_SIZE; y++) {
                for(let x=0; x<MAZE_SIZE; x++) {
                    if(mapData[y][x] === 1) {
                        // Raise walls slightly so they don't clip floor
                        const wall = new THREE.Mesh(geo, wallMat);
                        wall.position.set(x * TILE_SIZE + TILE_SIZE/2, TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2);
                        scene.add(wall);
                    } else {
                        // Floor
                        const floor = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE, 0.2, TILE_SIZE), floorMat);
                        floor.position.set(x * TILE_SIZE + TILE_SIZE/2, 0, y * TILE_SIZE + TILE_SIZE/2);
                        scene.add(floor);

                        // Ceiling
                        const ceil = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE, 0.2, TILE_SIZE), floorMat);
                        ceil.position.set(x * TILE_SIZE + TILE_SIZE/2, TILE_SIZE, y * TILE_SIZE + TILE_SIZE/2);
                        scene.add(ceil);
                    }
                }
            }

            camera.position.set(TILE_SIZE * 1.5, TILE_SIZE/2, TILE_SIZE * 1.5);

            // --- LIGHTING FIXES ---
            // 1. Strong Ambient Light (Base visibility)
            const ambient = new THREE.AmbientLight(0x606060); 
            scene.add(ambient);

            // 2. Player Lantern (Point Light instead of Spotlight for wider spread)
            const lantern = new THREE.PointLight(0xffaa00, 1.5, 25);
            lantern.position.set(0, 0, 0);
            camera.add(lantern); // Attach to player
            scene.add(camera);

            // Inputs
            document.body.addEventListener('click', () => {
                document.body.requestPointerLock();
                if(isLocked) shoot();
            });
            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === document.body;
                document.getElementById('instr').style.display = isLocked ? 'none' : 'block';
            });
            document.addEventListener('mousemove', (e) => {
                if(isLocked) {
                    camera.rotation.y -= e.movementX * 0.002;
                    // Limit look up/down
                    camera.rotation.x -= e.movementY * 0.002;
                    camera.rotation.x = Math.max(-1.0, Math.min(1.0, camera.rotation.x));
                }
            });
            document.addEventListener('keydown', (e) => onKey(e.code, true));
            document.addEventListener('keyup', (e) => onKey(e.code, false));
        }

        function onKey(code, state) {
            switch(code) {
                case 'KeyW': moveForward = state; break;
                case 'KeyS': moveBackward = state; break;
                case 'KeyA': moveLeft = state; break;
                case 'KeyD': moveRight = state; break;
            }
        }

        // --- COLLISION LOGIC ---
        function checkWall(x, z) {
            const gx = Math.floor(x / TILE_SIZE);
            const gy = Math.floor(z / TILE_SIZE);
            if(gx < 0 || gx >= MAZE_SIZE || gy < 0 || gy >= MAZE_SIZE) return true;
            return mapData[gy][gx] === 1;
        }

        function spawnEnemy() {
            if(enemies.length > 5) return; 
            
            let ex, ez, valid = false;
            // Retry 10 times to find empty spot
            for(let i=0; i<10; i++) {
                ex = Math.floor(Math.random() * MAZE_SIZE);
                ez = Math.floor(Math.random() * MAZE_SIZE);
                // Distance check + Wall check
                if(mapData[ez][ex] === 0 && Math.hypot(ex*TILE_SIZE - camera.position.x, ez*TILE_SIZE - camera.position.z) > 10) {
                    valid = true;
                    break;
                }
            }
            if(!valid) return;

            const geometry = new THREE.ConeGeometry(1, 2, 4); 
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000, wireframe: true });
            const enemy = new THREE.Mesh(geometry, material);
            
            // Center in tile
            enemy.position.set(ex * TILE_SIZE + TILE_SIZE/2, TILE_SIZE/2, ez * TILE_SIZE + TILE_SIZE/2);
            scene.add(enemy);
            enemies.push({ mesh: enemy, hp: 3 });
        }

        function shoot() {
            playSound('shoot');
            const raycaster = new THREE.Raycaster();
            const hitObjects = enemies.map(e => e.mesh);
            
            // 8-Ray Shotgun
            for(let i=0; i<8; i++) {
                const offset = new THREE.Vector2((Math.random()-0.5)*0.15, (Math.random()-0.5)*0.15);
                raycaster.setFromCamera(offset, camera);
                const intersects = raycaster.intersectObjects(hitObjects);

                if(intersects.length > 0) {
                    const hit = intersects[0];
                    if(hit.distance < 20) {
                        const enemyData = enemies.find(e => e.mesh === hit.object);
                        if(enemyData) {
                            enemyData.hp--;
                            playSound('hit');
                            hit.object.material.emissive.setHex(0xffffff); // Flash white
                            setTimeout(()=> { if(enemyData) enemyData.mesh.material.emissive.setHex(0x550000); }, 50);
                            
                            // Knockback
                            const push = hit.point.clone().sub(camera.position).normalize();
                            hit.object.position.add(push);

                            if(enemyData.hp <= 0) {
                                scene.remove(hit.object);
                                enemies = enemies.filter(e => e !== enemyData);
                                player.score += 100;
                                document.getElementById('hud').innerText = `HEALTH: ${player.health} | SCORE: ${player.score}`;
                            }
                        }
                    }
                }
            }
        }

        function update() {
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if(Math.random() < 0.02) spawnEnemy();

            // PLAYER MOVEMENT
            if (isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 80.0 * delta; // Faster
                if (moveLeft || moveRight) velocity.x -= direction.x * 80.0 * delta;

                const nextX = camera.position.x - velocity.x * delta;
                const nextZ = camera.position.z - velocity.z * delta;
                
                // SLIDE LOGIC: Check X and Z separately
                // Margin of 1.0 keeps us from clipping near walls
                const margin = 1.0; 

                // Try X movement
                if(!checkWall(nextX + (velocity.x > 0 ? -margin : margin), camera.position.z)) {
                    camera.translateX(-velocity.x * delta);
                }
                // Try Z movement
                if(!checkWall(camera.position.x, nextZ + (velocity.z > 0 ? -margin : margin))) {
                    camera.translateZ(-velocity.z * delta);
                }
                camera.position.y = TILE_SIZE/2; 
            }

            // ENEMY MOVEMENT (FIXED)
            enemies.forEach(e => {
                e.mesh.rotation.y += delta * 2;
                
                const vec = new THREE.Vector3().subVectors(camera.position, e.mesh.position);
                const dist = vec.length();
                vec.normalize();
                
                const moveSpeed = delta * 4.0;
                
                // Calculate next tentative positions
                const nextEX = e.mesh.position.x + vec.x * moveSpeed;
                const nextEZ = e.mesh.position.z + vec.z * moveSpeed;

                // ENEMY SLIDING LOGIC
                // We check if the CENTER of the enemy enters a wall cell.
                if(!checkWall(nextEX, e.mesh.position.z)) {
                    e.mesh.position.x = nextEX;
                }
                if(!checkWall(e.mesh.position.x, nextEZ)) {
                    e.mesh.position.z = nextEZ;
                }

                if(dist < 2.0) {
                    player.health -= 1;
                    document.getElementById('hud').innerText = `HEALTH: ${player.health} | SCORE: ${player.score}`;
                    if(player.health <= 0) {
                         alert("GAME OVER. Score: " + player.score);
                         location.reload();
                    }
                }
            });

            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }

        init();
        update();
    </script>
</body>
</html>